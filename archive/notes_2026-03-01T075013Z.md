# 笔记: gradio_app 启动失败(socksio 缺失)

## 现象

- 执行: `pixi run python tools/gradio_app.py`
- 报错: `ImportError: Using SOCKS proxy, but the 'socksio' package is not installed.`

## 初步判断

- Gradio 在 import 阶段会 import `httpx`.
- `httpx.Client(...)` 会读取环境变量代理配置(trust_env 默认开启).
- 当环境变量里包含 SOCKS 代理(例如 `ALL_PROXY=socks5://...`)时,httpx 需要可选依赖 `socksio`.

## 计划中的修复方向

- 优先: 在项目依赖中显式加入 `socksio`,并更新 `pixi.lock`.
- 备选: 启动时禁用代理环境变量(不推荐,会影响网络访问).

## 复现命令(确认根因)

- 仅当存在 SOCKS 代理环境变量时会触发:
  - `ALL_PROXY=socks5://127.0.0.1:1080 ./.pixi/envs/default/bin/python -c "import gradio"`
  - 报错与用户一致,来自 httpx 的 SOCKS transport 初始化阶段.

## 已采取的修复

- 在 `pyproject.toml` 的 `project.dependencies` 增加: `socksio>=1.0.0`
- 更新 `pixi.lock`,确保使用 Pixi 安装环境时也会包含 `socksio`

## 2026-02-24T08:45:14Z - ModelScope 镜像(FLUX.1-Fill-dev)

### 结论

- ModelScope 上的文件可以通过类似 HuggingFace 的 `resolve/<revision>/<path>` 直链访问,不需要额外 SDK.
- 直链示例(已用 curl 验证可读,且支持 Range):
  - `https://modelscope.cn/models/AI-ModelScope/FLUX.1-Fill-dev/resolve/master/ae.safetensors`
  - `https://modelscope.cn/models/AI-ModelScope/FLUX.1-Fill-dev/resolve/master/flux1-fill-dev.safetensors`

### 文件与校验(来自 files 页面内嵌 JSON)

- `ae.safetensors`
  - sha256: `afc8e28272cd15db3919bacdb6918ce9c1ed22e96cb12c4d5ed0fba823529e38`
- `flux1-fill-dev.safetensors`
  - sha256: `03e289f530df51d014f48e675a9ffa2141bc003259bf5f25d75b957e920a41ca`

## 2026-02-24T11:06:14Z - HuggingFace Xet(CAS) 下载失败的绕过

- 现象: `huggingface-cli download`/`hf download` 在部分仓库会走 xet/CAS,遇到网络抖动可能报 TLS unexpected EOF.
- 绕过: 通过环境变量 `HF_HUB_DISABLE_XET=1` 强制使用非 xet 的常规下载路径.

---

# 笔记: Remote-SSH 下 Rerun winit 无 DISPLAY + gRPC flush 报错

## 现象(来自运行日志)

- `winit EventLoopError: ... neither WAYLAND_DISPLAY nor WAYLAND_SOCKET nor DISPLAY is set`
- 退出时刷屏:
  - `Failed to flush sink: gRPC has been unable to connect to rerun+http://127.0.0.1:9876/proxy ...`

## 根因定位

- 关键点不是“我们没写 rr.init 导致 rerun 隐式 init”.
- 真正的副作用来自 `simplecv.rerun_log_utils.RerunTyroConfig`:
  - 该 dataclass 在 `__post_init__` 里会默认执行 `rr.spawn()`.
  - 这会尝试启动原生 Rerun Viewer(依赖 GUI/winit).
  - 在 Remote-SSH/无 GUI 的 Linux 环境里,必然触发 winit 的 DISPLAY/WAYLAND 缺失错误.
  - viewer 启动失败后,SDK 仍会尝试向 `rerun+http://127.0.0.1:9876/proxy` flush,于是出现 gRPC 连接失败刷屏.

## 验证信息(本地环境探测)

- rerun Python SDK 版本: 0.27.0
- 关键 API:
  - `rr.spawn(port=9876)` 会启动 viewer,需要 viewer 可执行文件且需要 GUI.
  - `rr.serve_grpc(grpc_port=9876)` 会在当前进程内启动 gRPC server,不依赖 GUI,返回可连接 URI.
  - `rr.connect_grpc()` 用于连接到已运行的 viewer(通常同机 9876).

## 修复策略

- 不再使用会产生副作用的 `simplecv.rerun_log_utils.RerunTyroConfig`.
- 用项目自有的纯数据配置 `VistaRerunConfig` 替代(字段兼容: application_id/recording_id/connect/save/serve/headless).
- 在 pipeline 真正开始记录前,显式调用 `init_rerun_from_config` 统一初始化:
  - 用户指定 `--rr-config.connect`: `rr.connect_grpc()`
  - 用户指定 `--rr-config.serve` 或无 GUI: `rr.serve_grpc(grpc_port=9876)`
  - 有 GUI 且未指定 connect/serve: `rr.spawn(port=9876)`

## 连接方向澄清(你现在的情况)

- 你本地能跑 GUI viewer,远端是无 GUI.
- 推荐模式是: 远端进程 `serve_grpc`,本地 viewer 通过 ssh `-L 9876:127.0.0.1:9876` 端口转发连接.
- 这样远端不需要 GUI,本地也不需要让远端反向连接你的电脑.

## 为什么 pipeline 会“自己终止”

- `rr.serve_grpc(...)` 会立即返回,并不会阻塞当前线程.
- gRPC server 依赖 Python 进程存活.
- pipeline 跑完后 Python 正常退出,server 一并停止,本地 viewer 连接也会断开.

## 改进

- 增加 `--rr-config.wait` 与 `--rr-config.wait-seconds N`:
  - 仅在启用了 gRPC server 时生效.
  - 用于让 pipeline 结束后保持进程存活,给本地 viewer 连接与检查的窗口.

---

# 笔记: 单图 pipeline 显存不足(OOM)的常见降显存手段

## 立刻可用(不改代码)

- 降低输入分辨率上限:
  - `--max-resolution 384` 或 `--max-resolution 512`
- 减少/关闭 outpaint:
  - 直接用 `--stage no-outpaint` 可跳过 Flux inpainting(通常省显存最明显).
- 减少扩边比例:
  - `--expansion-percent 0.1` 或更小(扩边越大,latent 越大,显存越高).

## 代码层改进(已落地)

- 对 `stage != coarse` 的情况,在 `_initialize()` 后主动释放 MoGe predictor 和 Flux inpainter,
  并 `gc.collect()` + `torch.cuda.empty_cache()`,降低后续 GS 训练/渲染峰值显存.
- `max_resolution` 支持更小的整数值(会向下对齐到 32 的倍数),便于在 8GB/12GB 显卡上跑通.
- MoGe predictor 改为延迟加载:
  - 避免在 Flux inpainting 把模型 `to(cuda)` 之前就占用大量显存,减少“只差几十 MiB 就 OOM”的情况.
- 增加 `depth_device` 参数:
  - `--depth-device cpu` 可作为显存不足时的兜底(更慢,但更稳).

---

# 笔记: 如何导出单图 pipeline 的高斯文件(3DGS PLY)

- 现状确认:
  - `src/vistadream/api/single_img_pipeline.py` 的 `SingleImagePipeline.__call__` 会调用 `save_ply(self.scene, ...)` 导出 PLY.
  - 旧版本的导出路径写死为 `data/test_dir/gf.ply`,且默认不打印,因此用户容易以为“没有输出文件”.
- 改良方向:
  - 把导出开关与导出路径变成 `SingleImageConfig` 的参数,由 tyro 自动暴露为 CLI.
  - `save_ply` 的压缩步骤依赖 `splat-transform`. 如果环境里缺少该工具,也不应该影响原始 PLY 的生成.

---

# 笔记: 高斯点云为什么看起来像“准圆的小圆点”(各向同性问题)

## 现象

- 用户反馈: 导出的“高斯点云”看起来像很多准圆的小圆点.
- 期望: 类似标准 3DGS 训练后的结果,高斯是各向异性的椭球,能更均匀覆盖形成内容.

## 初步判断(两类常见原因)

1. 可视化误解:
   - Rerun 的 3D 视图里我们记录的是 `Points3D` 点云,它不会像 3DGS renderer 一样渲染“椭球高斯”.
2. 参数本身接近各向同性:
   - `scale_0/1/2` 三个轴的差异很小.
   - `rot_0..3` 大量接近单位四元数,也会让投影结果更接近圆形.

## 证据: 对现有 `data/test_dir/gf.ply` 做统计(不依赖 plyfile,直接按 PLY header 解析二进制数据)

- 顶点数: `124637`
- `exp(scale)`(世界尺度)中位数(约):
  - x: `0.00447`
  - y: `0.00446`
  - z: `0.00449`
- 各向异性比例(用 `exp(scale)`):
  - x/y: median `~1.00`, p10 `~0.91`, p90 `~1.12`
  - x/z: median `~1.01`, p10 `~0.93`, p90 `~1.07`
- 旋转接近单位四元数:
  - `< 5°` 的“近单位旋转”数量: `114892 / 124637`

结论: 这份 PLY 的 scale/rotation 统计上确实偏各向同性,因此在支持 splat 的 viewer 里也容易呈现“准圆点”.

## 根因定位(代码层面)

- `src/vistadream/ops/gs/basic.py` 的 `Gaussian_Frame._coarse_init_scale_rotations()`:
  - `scale` 初始化为 `dpt / fx / sqrt(2)` 并在 3 个轴上 repeat,天然是各向同性.
  - `rotation` 初始化为单位四元数.
- 文件里存在 `_fine_init_scale_rotations()` 的思路(更像椭球),但目前没有给它提供 `self.nml`(法线),因此无法生效.

## 可能的改良方向(不引入额外模型)

- 从深度反投影得到 `xyz`,用相邻像素 3D 差分估计切向量/法线:
  - 用切向量 + 法线构建局部坐标系,初始化 rotation.
  - 用局部像素间距估计 x/y 方向的 scale,并让 z 更薄.
- 这样可以在初始化阶段就打破对称性,更接近 3DGS 的“变形高斯椭球”.

---

# 笔记: OpenSpec change - integrate-fastgs-continuous-surface

## 目标与约束(先记录,后续补全细节)

- 目标: 在仓库内生成 `openspec/changes/integrate-fastgs-continuous-surface/`,并拿到第一个 artifact 的 `instructions` 模板.
- 约束1: 连续表面 != 薄片(thinness). 本次不引入任何薄片/厚度正则.
- 约束2: "改良胜过新增". 规格阶段先把接口与数据流讲清楚,实现阶段尽量复用现有 pipeline 的深度/法线/掩码输出.

## 工具链约定

- 使用 pixi 环境的 `node` + `corepack`.
- pnpm/openspec 命令统一写法: `pixi run corepack pnpm <args>`.

## 生成结果(待补)

- change 路径: `openspec/changes/integrate-fastgs-continuous-surface/`
- workflow/schema: `spec-driven`
- `openspec status` 输出摘要:
  - Progress: `0/4`
  - `[ ] proposal`
  - `[-] design`(blocked by: proposal)
  - `[-] specs`(blocked by: proposal)
  - `[-] tasks`(blocked by: design, specs)
- 第一个 artifact 的 `instructions` 模板:
  - artifact id: `proposal`
  - 输出文件: `openspec/changes/integrate-fastgs-continuous-surface/proposal.md`
  - 模板原文见下(保留,便于后续直接按模板写 proposal)

## 2026-02-28T10:26:20Z - OpenSpec status 与 instructions 原文

### 环境信息

- pnpm: `10.30.3`(通过 `pixi run corepack pnpm -v`)
- openspec: `1.2.0`(通过 `pixi run corepack pnpm dlx @fission-ai/openspec@latest --version`)
- 备注: openspec 默认会提示匿名统计. 如需关闭,可以设置 `OPENSPEC_TELEMETRY=0`.

### `openspec status --change "integrate-fastgs-continuous-surface"`

```text
Change: integrate-fastgs-continuous-surface
Schema: spec-driven
Progress: 0/4 artifacts complete

[ ] proposal
[-] design (blocked by: proposal)
[-] specs (blocked by: proposal)
[-] tasks (blocked by: design, specs)
```

### `openspec instructions proposal --change "integrate-fastgs-continuous-surface"`

```text
<artifact id="proposal" change="integrate-fastgs-continuous-surface" schema="spec-driven">

<task>
Create the proposal artifact for change "integrate-fastgs-continuous-surface".
Initial proposal document outlining the change
</task>

<output>
Write to: /workspace/vistadream/openspec/changes/integrate-fastgs-continuous-surface/proposal.md
</output>

<instruction>
Create the proposal document that establishes WHY this change is needed.

Sections:
- **Why**: 1-2 sentences on the problem or opportunity. What problem does this solve? Why now?
- **What Changes**: Bullet list of changes. Be specific about new capabilities, modifications, or removals. Mark breaking changes with **BREAKING**.
- **Capabilities**: Identify which specs will be created or modified:
  - **New Capabilities**: List capabilities being introduced. Each becomes a new `specs/<name>/spec.md`. Use kebab-case names (e.g., `user-auth`, `data-export`).
  - **Modified Capabilities**: List existing capabilities whose REQUIREMENTS are changing. Only include if spec-level behavior changes (not just implementation details). Each needs a delta spec file. Check `openspec/specs/` for existing spec names. Leave empty if no requirement changes.
- **Impact**: Affected code, APIs, dependencies, or systems.

IMPORTANT: The Capabilities section is critical. It creates the contract between
proposal and specs phases. Research existing specs before filling this in.
Each capability listed here will need a corresponding spec file.

Keep it concise (1-2 pages). Focus on the "why" not the "how" -
implementation details belong in design.md.

This is the foundation - specs, design, and tasks all build on this.
</instruction>

<template>
<!-- Use this as the structure for your output file. Fill in the sections. -->
## Why

<!-- Explain the motivation for this change. What problem does this solve? Why now? -->

## What Changes

<!-- Describe what will change. Be specific about new capabilities, modifications, or removals. -->

## Capabilities

### New Capabilities
<!-- Capabilities being introduced. Replace <name> with kebab-case identifier (e.g., user-auth, data-export, api-rate-limiting). Each creates specs/<name>/spec.md -->
- `<name>`: <brief description of what this capability covers>

### Modified Capabilities
<!-- Existing capabilities whose REQUIREMENTS are changing (not just implementation).
     Only list here if spec-level behavior changes. Each needs a delta spec file.
     Use existing spec names from openspec/specs/. Leave empty if no requirement changes. -->
- `<existing-name>`: <what requirement is changing>

## Impact

<!-- Affected code, APIs, dependencies, systems -->
</template>

<success_criteria>
<!-- To be defined in schema validation rules -->
</success_criteria>

<unlocks>
Completing this artifact enables: design, specs
</unlocks>

</artifact>
```

---

## 2026-02-28T11:14:53Z - proposal 已完成,design/specs 已解锁

- 已写入 proposal 文件: `openspec/changes/integrate-fastgs-continuous-surface/proposal.md`.
- 已验证状态: `proposal` 完成后,`design` 与 `specs` 从 blocked 变为 ready.

### `openspec status --change "integrate-fastgs-continuous-surface"`

```text
Change: integrate-fastgs-continuous-surface
Schema: spec-driven
Progress: 1/4 artifacts complete

[x] proposal
[ ] design
[ ] specs
[-] tasks (blocked by: design, specs)
```

### 下一步(artifact 顺序提示)

- 现在可以开始写:
  - `openspec/changes/integrate-fastgs-continuous-surface/design.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/...(按 capabilities 拆分)`
- 两者完成后,才能写 `tasks` artifact.

---

## 2026-02-28T11:25:05Z - design/specs/tasks 已完成,OpenSpec change 完整闭环

- 已完成 artifacts:
  - `openspec/changes/integrate-fastgs-continuous-surface/design.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-dataset-export/spec.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-refine/spec.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/continuous-surface-supervision/spec.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/tasks.md`

### `openspec status --change "integrate-fastgs-continuous-surface"`

```text
Change: integrate-fastgs-continuous-surface
Schema: spec-driven
Progress: 4/4 artifacts complete

[x] proposal
[x] design
[x] specs
[x] tasks

All artifacts complete!
```

---

# 笔记: fastgs-dataset-export 的落地约定(实现阶段)

## 目录结构(最终以 spec 为准)

- `images/`: 以零填充索引命名的 PNG(例如 `000000.png`)
- `sparse/0/`: COLMAP text 模型
  - `cameras.txt`
  - `images.txt`
- `priors/depth/`: float32 深度先验(例如 `000000.npy`)
- `priors/normal/`: float32 法线先验(例如 `000000.npy`,shape=H*W*3)
- `masks/`: 有效像素掩码 PNG(例如 `000000.png`,255 表示有效)
- `meta.json`: 记录 views 映射、坐标系约定、以及导出来源(单图/多图)

## mask 语义(先定一个清晰可复现的版本)

- mask=有效像素(参与几何监督/指标统计的像素).
- single-image:
  - 优先使用 `Frame.inpaint_wo_edge`(已排除深度边界 + 低置信度).
  - 若缺失则回退到 `Frame.dpt_conf_mask`,再回退到 `depth>0 & finite`.
- multi-image:
  - 使用 `depth_conf>0` 与 `~depth_edges_mask` 的交集,并额外要求 `depth>0 & finite`.

## normal priors(先用深度几何估计,后续可替换为网络预测)

- 若 pipeline 没有直接输出 normal prior,则用 depth + K 反投影得到 xyz,用相邻像素差分估计切向量,再用叉乘得到法线并归一化.
- 后续 refine 的法线损失使用 `1 - abs(dot)` 规避符号歧义,因此法线朝向无需强行统一.

---

# 笔记: continuous-surface-supervision 的实现要点(实现阶段)

## 2026-02-28T12:39:33Z

- 深度对齐(scale+shift):
  - 目标: 把 depth prior(可能是相对深度)对齐到当前渲染深度的尺度.
  - 做法: 在 mask 有效像素上解最小二乘,得到 `scale,shift`,并在 loss 中使用 `aligned_prior = scale * prior + shift`.
  - 稳定性: 计算 `scale,shift` 时对渲染深度做 detach,避免梯度通过对齐参数“抵消”监督.

- 渲染法线:
  - 由渲染 depth + K 反投影得到 xyz,再用相邻差分估计 normal.
  - 由于 normal 监督使用 `abs(dot)` 符号不敏感,不需要强行统一朝向.

- 坐标系约定:
  - refine 渲染需要 `cam_T_world`(world->cam view matrix).
  - dataset 导出侧可以继续保存 `world_T_cam`(cam->world pose),refine 侧读取后再 `inv()` 得到 `cam_T_world`.

- 硬约束:
  - 本次实现不引入 thinness/thickness/薄片正则.
  - 如配置/参数里出现相关字段,应直接报错退出.

---

# 笔记: `--stage coarse` 与 `--stage fine` 的 PLY 为什么肉眼差异不明显

## 2026-03-01T06:14:26Z

### 对比对象

- `data/test_dir/gf.ply`(通常来自 `--stage fine` 或初始化阶段产物)
- `data/coarse/gf_coarse.ply`(来自 `--stage coarse` 产物)

### 关键事实(用数值代替肉眼)

- 两个文件大小都约 30MiB,但 sha256 不同,说明不是同一文件覆盖出来的副本.
- 顶点数(高斯 splats 数量):
  - `data/test_dir/gf.ply`: 124,746
  - `data/coarse/gf_coarse.ply`: 124,517
  - 差值: 229(约 0.18%),这个量级在点云可视化里基本很难肉眼看出变化.

- xyz 统计(均值/方差/包围盒)几乎一致.
- 最近邻距离(粗略几何重合程度):
  - 点云内部最近邻均值约 0.0054
  - coarse -> fine 最近邻均值约 0.00437
  - fine -> coarse 最近邻均值约 0.00439
  - 解释: 两个点云高度重叠,仅存在轻微漂移或局部细节差异.

### 初步推断(需要在代码里把事实打印出来验证)

- `--stage coarse` 可能没有选到足够多的新视角帧,或选帧很少,导致新增 splats 很有限.
- coarse 选帧策略本身偏保守(洞比例阈值 + 相邻帧剔除),容易出现 "退化成只做 initialize" 的情况.
- 新增 splats 来源会被 `inpaint_wo_edge` 强过滤,即使选到帧,也可能只增加很少的高置信像素点.

---

# 笔记: FreeTimeGsVanilla 的 "COLMAP + RoMa(romatch) 密集匹配/三角化" 与 Vistadream 的可借鉴点

## 2026-03-01T06:16:55Z

### 1) 先澄清概念: FreeTimeGsVanilla 并不是 "让 COLMAP 用 RoMa 做 SfM"

FreeTimeGsVanilla 的数据准备脚本已经把意图写得很直白:

> "mp4 -> FreeTimeGS 数据准备(抽帧 + 参考帧 COLMAP + RoMA 逐帧三角化)" (`src/preprocess_mp4_freetimegs.py`)

它的设计原则也明确区分了 COLMAP 与 RoMa 的职责:

> "相机位姿静态: 只在 reference_frame 跑一次 COLMAP." (`src/preprocess_mp4_freetimegs.py`)

因此,这里的 "COLMAP 环节" 更像是 "先标定静态相机 rig",而不是每帧都跑 SfM.

### 2) RoMa 在 FreeTimeGsVanilla 里的真实用途

它用的是 RoMa 的开源实现 `romatch`,入口是:

> "from romatch import roma_outdoor" (`src/preprocess_mp4_freetimegs.py`)

核心流程是:

> "anchor 与每个其它相机做 RoMA 匹配,再 RANSAC 过滤,再三角化." (`src/preprocess_mp4_freetimegs.py`)

实现上还做了几件很关键的工程化处理:

- 外点过滤:
  - 用 `cv2.findFundamentalMat(..., method=cv2.USAC_MAGSAC, ...)` 先过滤匹配外点.
  - 再做 cheirality(两相机深度都 > 0)与 NaN/Inf 过滤.
- 规模控制:
  - 合并所有相机对的点后做 voxel 去重,避免点数量爆炸.
- 可用性兜底:
  - `romatch` 的自定义 CUDA 扩展 `local_corr` 若缺失,自动降级 `use_custom_corr=False`,牺牲速度换可跑通.

### 3) Vistadream 当前的 "colmap 相关" 是导出格式,不是依赖 COLMAP 求解

Vistadream 里出现 `colmap` 的地方,目前主要是把 learned 的结果写成 COLMAP txt 兼容格式:

> "Write camera intrinsics to COLMAP cameras.txt format." (`src/vistadream/api/multi_image_pipeline.py`)

并且配置里也把它表述为 "Output directory for colmap version":

> "Output directory for colmap version. If None, results are not saved." (`src/vistadream/api/multi_image_pipeline.py`)

也就是说,它并没有 "COLMAP 阶段" 需要更密集的 feature matching.

另外需要特别注意命名陷阱:

- Vistadream 的依赖里有 `roma`(PyPI 包),但 FreeTimeGsVanilla 用的是 `romatch`(RoMa dense matching).
- 两者不是一回事,不要因为名字像就误判为 "项目已经引入 RoMa".

### 4) 结论: 借鉴价值主要在 "场景匹配" 与 "工程套路",不是直接照搬

当输入形态是:

- 多相机静态 rig
- 逐帧动态场景

RoMa 的密集匹配 + 已知位姿三角化,确实能提供 "每帧几何点云" 这种 Vistadream 当前主流程并不覆盖的能力.

但如果我们讨论的是 Vistadream 的单图/少图路线:

- 单图: 没有跨视图匹配,RoMa 基本无用.
- 少图: Vistadream 已经走 learned multiview(位姿+深度)并产出较密的点云,RoMa 更像是额外的几何 sanity check,不是必需组件.

如果未来要落地,推荐优先考虑 "轻量借鉴"(task_plan.md 里的方案B):

- 只把 RoMa 三角化做成可选 debug/自检工具.
- 用于筛掉明显坏帧/坏视角组合,或与 learned depth 点云做一致性对照.

---

# 笔记: coarse 选不到新帧时如何定位原因

## 2026-03-01T07:28:24Z

### 背景

- 你这次 `--stage coarse` 日志里出现:
  - `selected_extra_frames=0/8`
  - `No more suitable frames found for inpainting`
- 这意味着 coarse 直接退化成“只初始化 2 帧(input+outpaint)”,所以导出的 PLY 和 `fine/outpaint` 很像.

### 选不到帧的 3 类根因

1. 洞太小: 所有候选 `inpaint_ratio < coarse_min_inpaint_ratio`.
2. 洞太大: 所有候选 `inpaint_ratio > coarse_max_inpaint_ratio`.
3. 相邻剔除导致: 有一些候选本来在 [min,max] 内,但被 `coarse_adjacent_exclusion` 全部剔除了.

### 现在的可观测输出(新增)

- 当 `_next_frame()` 选不到帧时,会打印 `[COARSE][DIAG]`:
  - `inpaint_ratio(valid) stats: min/mean/max`
  - `counts(valid): below_min / in_range / above_max`
  - `topK(idx:ratio)=...`
  - 并给出“应该调哪类参数”的建议(调 motion/margin 还是调 min/max).

### 显式更激进的兜底

- 新增 `--coarse-fallback-mode closest`:
  - 严格模式选不到时,会选一个“最接近 [min,max] 区间”的候选帧继续推进.
  - 这通常能让 coarse 至少选到新帧,从而更容易在 PLY 上看到差异.
