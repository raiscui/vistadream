# 任务计划: 修复 gradio_app 启动时报 socksio 缺失

## 目标

`pixi run python tools/gradio_app.py` 可以正常启动(至少不再在 import 阶段崩溃).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. 为什么 httpx 会尝试使用 SOCKS proxy?
2. 如何在不破坏现有环境的情况下,让 Gradio 在有 SOCKS proxy 的机器上也能启动?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳定): 在依赖中补齐 socksio

- 思路: httpx 检测到 SOCKS proxy 时会需要 `socksio`. 让依赖显式包含它,避免环境变量触发时直接崩溃.
- 优点: 不依赖用户手动 unset 环境变量. 在公司代理/开发机常见配置下更稳.
- 代价: 增加一个很小的运行时依赖.

### 方案B(先能用,但不推荐): 启动前禁用/清理 SOCKS proxy 环境变量

- 思路: 让 httpx 不走 SOCKS 代理,就不会触发 socksio 依赖.
- 优点: 不改依赖,最快.
- 风险: 会影响通过代理访问网络的能力(例如下载模型/访问 HuggingFace).

## 做出的决定

- [2026-02-24T07:33:33Z] 选择方案A: 直接补齐 `socksio` 依赖,并更新 `pixi.lock`. 原因: 这是根因修复,不改变用户的代理设置,也更可复现.

## 遇到错误

- (暂无)

## 状态

**已完成**: `tools/gradio_app.py` 在 SOCKS 代理环境变量开启时,不再因 `socksio` 缺失而在 import 阶段崩溃.

## 进展日志

- [2026-02-24T07:34:43Z] 通过设置 `ALL_PROXY=socks5://127.0.0.1:1080` 复现同样的 ImportError. 确认触发点是 `gradio -> httpx` 在初始化代理 transport 时检测到 SOCKS proxy,但缺少 `socksio`.
- [2026-02-24T07:39:37Z] 已在 `pyproject.toml` 增加 `socksio>=1.0.0`,并更新 `pixi.lock` 以保证可复现安装.
- [2026-02-24T07:46:46Z] 验证通过: 在设置 `ALL_PROXY=socks5://127.0.0.1:1080` 的情况下,`import gradio` 以及 `runpy.run_path('tools/gradio_app.py', run_name='__test__')` 均不再抛 `ImportError`.
- [2026-02-24T07:49:18Z] 补充安全性: 将 `.envrc.private` 加入 `.gitignore`,避免本地私密配置/Token 被误提交到仓库.

---

# 任务计划: 为 flux1-fill-dev 增加 ModelScope 镜像支持

## 目标

当 `ckpt/flux_fill/flux1-fill-dev.safetensors` / `ckpt/flux_fill/ae.safetensors` 缺失时:

1. 程序不会用奇怪的路径拼接方式崩溃.
2. 可以自动从 ModelScope 下载(或在 HuggingFace 可用时回退到 HuggingFace).
3. README 提供明确的手动下载方式.

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. ModelScope 上的 FLUX.1-Fill-dev 权重,是否能用稳定的直链方式下载?
2. 下载逻辑放在哪里影响最小,又能被 `gradio_app`/pipeline 复用?
3. 23GB 级别的下载,如何支持断点续传,避免一次失败就重来?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳定): util.py 内置自动下载 + HuggingFace 回退

- 思路: 当本地 ckpt 不存在时,先用 ModelScope 的 `resolve/master/...` 直链下载到 `ckpt/flux_fill/`.
- 同时保留 HuggingFace 的下载能力作为回退(或未来扩展到其它 FLUX 权重).
- 优点: 用户直接运行 `tools/gradio_app.py` 或 pipeline,缺文件时不会直接崩,能自动补齐.
- 风险: 首次运行可能触发大文件下载,需要有心理预期(这本来也是必需文件).

### 方案B(先能用,但更手工): 只更新 README/任务脚本,不改运行时下载逻辑

- 思路: 在 README 中提供 ModelScope 的下载命令,让用户手动把文件放到 `ckpt/flux_fill/`.
- 优点: 不会在运行时触发大下载,行为更可控.
- 缺点: 依赖用户手动操作,也更容易因为少下一个文件而报错.

## 做出的决定

- [2026-02-24T08:45:14Z] 选择方案A,并同时补充 README 的手动下载命令(吸收方案B的可控性). 原因: 当前代码在缺文件时会直接崩,这是体验问题; 自动下载能把问题变成可恢复路径.

## 状态

**已完成**: `flux-dev-fill` 在缺少本地权重文件时,会优先从 ModelScope 下载(失败则回退 HuggingFace),并修复了旧逻辑的错误路径拼接与 AE 加载不一致问题.

## 进展日志

- [2026-02-24T08:45:14Z] 确认 ModelScope 可用直链: `https://modelscope.cn/models/AI-ModelScope/FLUX.1-Fill-dev/resolve/master/<file>`,且支持 Range 断点续传.
- [2026-02-24T09:00:21Z] 实现: `src/vistadream/flux/util.py` 新增 ModelScope 下载器(断点续传),并让 `load_flow_model/load_ae/load_cond_ae` 走统一的 `_ensure_checkpoint_file` 逻辑.
- [2026-02-24T09:00:21Z] 文档: `README.md` 补充 ModelScope 手动下载命令(支持 resume),并说明 flux fill 权重优先使用 ModelScope 镜像.

- [2026-02-24T11:06:14Z] 发现 README 仍建议执行 `pixi run huggingface-cli download pablovela5620/vistadream --local-dir ckpt/`,该路径会触发 HuggingFace 的 Xet(CAS) 下载,在部分网络环境下易出现 TLS unexpected EOF. 已将 README 调整为优先推荐 ModelScope 直链下载,并补充如仍需 HuggingFace 快照时可用 `HF_HUB_DISABLE_XET=1 pixi run hf download ...` 禁用 Xet.

---

# 任务计划: Remote-SSH 环境下 Rerun 连接失败(winit 无 DISPLAY + gRPC flush 报错)

## 目标

在 VSCode Remote SSH 的无 GUI 环境里运行:

- `python tools/run_single_img.py --image-path ...`

不会再因为 Rerun Viewer 尝试启动 GUI 而报:

- `winit EventLoopError: ... neither WAYLAND_DISPLAY nor WAYLAND_SOCKET nor DISPLAY is set`

并且能够用本地的 Rerun Viewer 稳定连接查看日志,避免退出时刷屏:

- `Failed to flush sink: gRPC has been unable to connect to rerun+http://127.0.0.1:9876/proxy ...`

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. 为什么在无 GUI 环境里会触发 `rr.spawn()` 并导致 winit 报 DISPLAY/WAYLAND 缺失?
2. 无 DISPLAY/WAYLAND 的远端环境,应该走 `serve_grpc` 还是 `connect_grpc`?
3. 用户已做 9876 端口转发,应该是 "本地 viewer 连接远端 server" 还是相反方向?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳): 显式初始化 Rerun,并在无 GUI 时自动切到 `serve_grpc`

- 思路:
  - 禁止隐式 init,由项目代码统一 `rr.init(...)`.
  - 有 GUI 时默认 `rr.spawn()`(和本地体验一致).
  - 无 GUI 时自动 `rr.serve_grpc(grpc_port=9876)`,打印连接提示,让本地 viewer 通过端口转发连接.
- 优点: 用户不需要记忆额外参数. Remote-SSH 下不会再尝试启动 GUI viewer.
- 代价: 需要在多个 pipeline 入口处补齐统一的 rerun 初始化逻辑.

### 方案B(先能用,但更依赖用户): 只给出运行指引,要求用户显式传参

- 思路: 要求用户运行时指定 `--rr-config.headless true --rr-config.serve true`,并处理好 ssh 端口转发方向.
- 优点: 不改代码,最快.
- 风险: 容易忘记参数,体验不稳定,且错误会反复出现.

## 做出的决定

- [2026-02-24T13:05:00Z] 选择方案A. 原因: 根因是配置对象构造期的副作用导致默认 spawn GUI viewer,在无 DISPLAY 场景必崩. 代码层面统一处理,对专业用户更可靠.

## 状态

**已完成**: Remote-SSH 无 GUI 环境下不再触发 Rerun 原生 Viewer 的 spawn,默认改为 `serve_grpc` 并输出可连接 URI; 本地 viewer 可通过 ssh 端口转发稳定连接,不再出现 gRPC flush 刷屏报错.

## 进展日志

- [2026-02-24T13:10:00Z] 通过 Python 运行时探测确认 rerun SDK 为 0.27.0,具备 `serve_grpc/connect_grpc/spawn` 等 API.
- [2026-02-24T13:12:00Z] 复现并确认根因: `simplecv.rerun_log_utils.RerunTyroConfig` 在 `__post_init__` 中默认执行 `rr.spawn()`,属于配置构造期副作用,会早于 pipeline 逻辑执行.
- [2026-02-24T13:18:00Z] 实现: 新增 `src/vistadream/rerun_setup.py` 的 `VistaRerunConfig` 与 `init_rerun_from_config`,并在 single/multi/outpainting 三条入口在首次 `rr.*` 前显式初始化.
- [2026-02-24T13:20:00Z] 文档: `README.md` 补充 Remote-SSH 场景下的 ssh `-L 9876:127.0.0.1:9876` 端口转发与本地 `rerun --connect` 示例命令.

---

# 任务计划: Rerun serve_grpc 模式下任务结束后可选等待,避免进程退出导致 viewer 断开

## 目标

当在无 GUI 环境下自动/手动启用 `serve_grpc` 时:

- pipeline 跑完不会“立刻退出导致本地 viewer 来不及连接”.
- 用户可以通过 CLI 参数选择:
  - 等待回车退出,或
  - 等待 N 秒后退出,或
  - 保持原行为(跑完立刻退出).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. `serve_grpc` 是否会阻塞进程? (结论: 不会,它立即返回,server 依赖进程存活)
2. 什么等待行为对 Remote-SSH 最友好? (结论: 默认不等待,但提供 `--rr-config.wait/--rr-config.wait-seconds` 可选开关)

## 可选方案(至少两个方向)

### 方案A(最佳方案,更可控): 新增 rr-config 等待参数,由用户显式开启

- 思路: `VistaRerunConfig` 增加 `wait`/`wait_seconds`,仅在 `serve_grpc` 生效.
- 优点: 不改变默认行为,不会让 CI/脚本无故挂住.
- 缺点: 用户需要记得加参数.

### 方案B(先能用,但可能踩坑): headless 时默认等待回车

- 思路: 无 GUI 场景自动等待回车,直到用户确认退出.
- 优点: 很直观,不容易错过连接窗口.
- 风险: 非交互场景(比如批处理/CI)会卡死,不推荐作为默认.

## 做出的决定

- [2026-02-24T13:40:00Z] 选择方案A. 原因: 默认行为必须可脚本化; 等待应是显式意图.

## 状态

**已完成**: `serve_grpc` 场景下可通过 `--rr-config.wait`/`--rr-config.wait-seconds` 让 pipeline 在结束后保持进程存活,避免本地 viewer 来不及连接.

## 进展日志

- [2026-02-24T13:50:00Z] 在 `VistaRerunConfig` 增加 `wait/wait_seconds`,并实现 `maybe_wait_after_run`(仅当启用 gRPC server 时生效; 默认不等待,但输出提示).
- [2026-02-24T13:52:00Z] 在 single/multi/outpainting 三条入口主流程结束处调用 `maybe_wait_after_run`.
- [2026-02-24T13:54:00Z] 更新 `README.md` 增加 Remote-SSH 场景下的等待参数示例.

---

# 任务计划: 单图 `stage=fine` Flux inpainting 阶段 OOM(只差几十 MiB)的根因修复

## 目标

在 24GB 显卡上运行 `tools/run_single_img.py --stage fine` 时:

- 不再因为 Flux inpainting 在 `model.to(cuda)` 阶段只差几十 MiB 就 OOM.
- 提供可用的兜底手段(例如把 MoGe 深度模型切到 CPU).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. OOM 是否发生在 Flux 推理阶段? (结论: 是,堆栈指向 `FluxInpainting.__call__` 的 `model.to(cuda)`)
2. 为什么 offload 仍会 OOM? (结论: Flux 主模型搬到 GPU 仍需要接近满显存; 其他常驻模型会抬高基线)
3. 是什么常驻占用了显存? (结论: `SingleImagePipeline.__init__` 里提前创建的 MoGe predictor 常驻 GPU)

## 可选方案(至少两个方向)

### 方案A(最佳方案,根因修复): MoGe predictor 延迟加载 + 可选 CPU 兜底

- 思路:
  - 不在 `__init__` 就把 predictor 常驻 GPU.
  - 真正需要深度预测时再创建 predictor.
  - 增加 `--depth-device cpu` 兜底.
- 优点: 直接降低 Flux inpainting 的显存基线,对 “差几十 MiB” 特别有效.
- 代价: 第一次用到深度预测时才会初始化 predictor,启动稍延后(但总耗时差不多).

### 方案B(先能用,但效果有限): 只加 `empty_cache` / 调参降分辨率

- 思路: 用 `torch.cuda.empty_cache()`/`PYTORCH_CUDA_ALLOC_CONF` 缓解碎片,再靠 `--max-resolution` 降峰值.
- 优点: 实现简单.
- 风险: 对“模型本体就是装不下”的情况无能为力,且需要用户不断试参.

## 做出的决定

- [2026-02-24T14:25:00Z] 选择方案A,同时吸收方案B 的 `empty_cache` 作为辅助. 原因: 用户的堆栈是典型的“基线占用导致差一点 OOM”,延迟加载能从根因降低基线.

## 状态

**已完成**:

- `SingleImagePipeline` 的 MoGe predictor 改为延迟加载,并新增 `depth_device` 参数.
- `FluxInpainting` 在 offload 切换阶段补充 `torch.cuda.empty_cache()`.
- `README.md` 补充 `--depth-device cpu` 作为 OOM 兜底说明.

---

# 任务计划: `run_single_img` 支持导出高斯(3DGS)文件(PLY),并让导出路径可配置

## 目标

你运行:

- `pixi run python tools/run_single_img.py --image-path ... --stage coarse ...`

时:

1. 明确告诉你高斯文件输出到哪里(默认路径 + 控制台提示).
2. 允许你用 CLI 参数指定导出的 PLY 路径,避免写死到 `data/test_dir/gf.ply`.
3. 如果环境里没有 `splat-transform`,也不影响生成原始 `*.ply`(仅跳过压缩步骤,并给出清晰提示).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. 当前版本是否已经在导出 PLY? (需要确认导出路径与触发条件)
2. 为什么用户会觉得没导出? (路径写死 + 没打印 + 压缩工具缺失时输出噪音/误导)
3. 用最小破坏的方式,如何把导出路径暴露为 CLI 参数? (tyro dataclass 增加字段)

## 可选方案(至少两个方向)

### 方案A(最佳方案,根因改良): 在 `SingleImageConfig` 增加导出开关 + 导出路径参数,并在结束时打印输出路径

- 思路:
  - `SingleImageConfig` 新增 `export_gaussians`/`export_gaussians_ply_path`.
  - 默认值保持与当前行为一致(仍导出到 `data/test_dir/gf.ply`),但让用户可覆盖.
  - `save_ply` 内部用 `shutil.which("splat-transform")` 查找压缩工具,找不到就跳过压缩并提示.
- 优点: 用户体验最直接,且不改变默认产物.
- 代价: 增加少量配置字段与一段输出提示.

### 方案B(先能用,但治标): 仅在 README 写死提示 "文件在 data/test_dir/gf.ply"

- 优点: 不改代码,最快.
- 缺点: 仍然写死路径,未来很容易踩坑(覆盖/找不到/多次运行混淆).

## 做出的决定

- [2026-02-24T15:19:52Z] 选择方案A. 原因: 这是典型“写死路径导致用户看不到产物”的问题,应该在代码层面给出可控的恢复路径.

## 状态

**已完成**: 单图 pipeline 默认导出 `data/test_dir/gf.ply`,并支持用 CLI 配置导出路径/开关; 压缩工具缺失时不再误导为“导出失败”.

## 进展日志

- [2026-02-24T15:19:52Z] 确认现状: `SingleImagePipeline.__call__` 里已经会调用 `save_ply(self.scene, ...)`,但导出路径写死为 `data/test_dir/gf.ply`,且没有明确打印.
- [2026-02-24T15:19:52Z] 改良: `SingleImageConfig` 增加 `export_gaussians` 与 `export_gaussians_ply_path`,并在导出时输出明确的 `[INFO] Exporting ...` 日志.
- [2026-02-24T15:19:52Z] 改良: `save_ply` 压缩逻辑改为优先 `shutil.which(\"splat-transform\")`,找不到则跳过压缩并提示,避免误导用户“好像导出失败”.
- [2026-02-24T15:19:52Z] 文档: `README.md` 增加默认导出路径与如何覆盖/关闭导出.
- [2026-02-24T15:19:52Z] 验证: `python3 -m compileall src/vistadream/api/single_img_pipeline.py src/vistadream/ops/gs/basic.py` 通过.

---

# 任务计划: 高斯点云看起来像小圆点,缺少 3DGS 的各向异性覆盖效果

## 目标

当你运行单图/多图 pipeline 并查看输出时:

1. 导出的 3DGS PLY 里,高斯的 `scale_*` 和 `rot_*` 不再几乎全是“各向同性 + 近单位旋转”,而是能体现表面方向的各向异性(更像 3DGS 的“变形高斯椭球”).
2. 文档明确说明: Rerun 的 3D 视图里记录的是 `Points3D` 点云调试视图,它不会像 3DGS viewer 那样渲染椭球高斯,避免“看起来都是圆点”的误解.

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. 你看到的“小圆点”来自哪里? (Rerun 的 `Points3D` 可视化,还是 3DGS PLY 在某个 viewer 里的 splat 渲染)
2. 当前导出的 PLY 是否确实接近各向同性? (scale 比例接近 1,rotation 接近单位四元数)
3. 在不引入额外模型的前提下,能否用深度几何(局部切平面/法线)来初始化各向异性 scale + rotation,打破对称性?

## 可选方案(至少两个方向)

### 方案A(最佳方案,根因改良): 用深度几何估计局部切平面,初始化各向异性 scale + rotation

- 思路:
  - 从深度 + 内参反投影出相机坐标系下的 `xyz`.
  - 用相邻像素的 3D 差分估计切向量与法线.
  - 以切向量/法线构建每个高斯的局部坐标系,生成 `rotation`(四元数).
  - 以像素在 3D 中的局部间距估计 `scale_x/scale_y`,并让 `scale_z` 更薄(类似 surfel),得到更像 3DGS 的椭球.
- 优点: 不需要多视角也能打破“全是圆点”的对称性,导出 PLY 在 3DGS viewer 里会更像“变形高斯”.
- 风险: 深度噪声会影响法线,需要做数值兜底(无效深度/退化向量回退到 coarse init).

### 方案B(先能用,但治标): 只做可视化/文档澄清,不改高斯参数初始化

- 思路:
  - 明确说明 Rerun 的 3D 视图只是点云,不要用它判断高斯是否“变形”.
  - 提供一个最小的 PLY 统计脚本/指引,让用户确认 scale/rotation 是否接近各向同性.
- 优点: 低风险,不改变模型行为.
- 缺点: 不能解决“导出 PLY 在 3DGS viewer 里也像圆点”的情况.

## 做出的决定

- [2026-02-27T05:36:05Z] 倾向先做方案A,并补上方案B的文档澄清. 原因: 目前代码初始化是各向同性,会天然导向“圆点”; 用深度几何初始化能从根源打破对称性.

## 遇到错误

- (暂无)

## 状态

**已完成**: 修复/改良高斯初始化与可视化说明,让 PLY 更容易呈现 3DGS 风格的各向异性椭球,并减少 Rerun 点云视图造成的误解.

## 进展日志

- [2026-02-27T05:36:05Z] 读取 `data/test_dir/gf.ply`(binary little endian)做统计: `scale_x/scale_y` 中位数约 1.00,rotation 大量接近单位四元数,因此在 viewer 里呈现“准圆点”是可预期的.
- [2026-02-27T05:44:28Z] 改良 `Gaussian_Frame` 初始化: 用深度反投影得到的 `xyz` 做局部切平面估计,生成各向异性 `scale` 与非平凡 `rotation`,并在数值退化时回退到 coarse 初始化.
- [2026-02-27T05:44:28Z] 改良可视化: Rerun `Points3D` 记录的 radii 由 `exp(scale)` 均值生成(避免把 log-scale 当半径导致误导/全是小点).
- [2026-02-27T05:44:28Z] 文档与工具: README/docs 增加“为什么看起来像圆点”的解释,并新增 `tools/analyze_gs_ply.py` 用于快速体检 PLY 的 scale/rotation 统计.

---

# 任务计划: 生成 OpenSpec change: integrate-fastgs-continuous-surface

## 目标

在仓库内生成 `openspec/changes/integrate-fastgs-continuous-surface/`.
同时拿到第一个 artifact 的 `instructions` 模板.
把它们追加写入 `notes.md`.
后续用规格驱动方式引入 "正确的 3DGS 连续表面训练方法"(连续表面 != 薄片).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. 当前环境是否已有 `pnpm` 与 `openspec` CLI? 如果没有,如何在不污染系统环境的前提下运行?
2. OpenSpec CLI 的 npm 包名是什么? 是否能用 `pnpm dlx` 直接运行?
3. 默认 workflow schema 的 artifact 顺序是什么? 第一个 "ready" artifact id 是哪个?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更可复现): 固化为项目级工具/任务

- 思路:
  - 给仓库增加一个固定入口(例如 pixi task 或脚本),用固定版本运行 OpenSpec.
  - 例如: `pixi run corepack pnpm dlx @fission-ai/openspec@<pinned> ...`.
- 优点:
  - 团队成员命令一致,版本可控.
  - 更容易接入 CI.
- 代价:
  - 需要新增少量 repo 配置/脚本.

### 方案B(先能用,最小侵入): 用 `pnpm dlx` 直接运行 OpenSpec(推荐)

- 思路:
  - 使用 pixi 环境的 `node` + `corepack` 准备 pnpm.
  - 全程用 `pixi run corepack pnpm dlx ...` 运行 OpenSpec.
- 优点:
  - 不需要全局安装,不污染系统环境.
  - 先把 change scaffold 生成出来,马上进入写 artifact 的阶段.
- 代价:
  - 默认跟随 `@latest`,未来若需要可再 pin 版本.

## 做出的决定

- [2026-02-28T10:22:12Z] 选择方案B. 原因: 先把 change scaffold 生成出来,再决定是否 pin 版本/上 CI.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已生成 `openspec/changes/integrate-fastgs-continuous-surface/`,并把 status/instructions 原文落盘到 `notes.md` 与 `WORKLOG.md`.

## 进展日志

- [2026-02-28T10:22:12Z] 确认现状: `openspec`/`pnpm` 在系统 PATH 内均不可用,但 pixi 环境有 `node` + `corepack`,可用于安装/运行 pnpm.
- [2026-02-28T10:26:20Z] 已准备 pnpm: `pixi run corepack prepare pnpm@latest --activate`,并通过 `pixi run corepack pnpm -v` 验证为 `10.30.3`.
- [2026-02-28T10:26:20Z] 已验证 openspec 可运行: `pixi run corepack pnpm dlx @fission-ai/openspec@latest --version` 输出 `1.2.0`.
- [2026-02-28T10:26:20Z] 已创建 change: `openspec/changes/integrate-fastgs-continuous-surface/`(schema: `spec-driven`).
- [2026-02-28T10:26:20Z] `openspec status` 显示第一个 artifact 为 `proposal`,其余 artifacts 均被阻塞(blocked).
- [2026-02-28T10:26:20Z] 已获取 `proposal` 的 `instructions` 模板,并把 status/instructions 原文追加到 `notes.md`.
- [2026-02-28T10:28:29Z] 已把本次完成的动作追加记录到 `WORKLOG.md`,并标记阶段4完成.

---

# 任务计划: 编写 OpenSpec proposal: integrate-fastgs-continuous-surface

## 目标

完成 `openspec/changes/integrate-fastgs-continuous-surface/proposal.md`.
并确保 `openspec status` 将 `proposal` 标记为已完成,从而解锁 `design` 与 `specs`.

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. proposal 里如何清晰表达 "连续表面" 的验收目标,同时避免被误读成 "薄片/厚度正则"?
2. 能力拆分(capabilities)如何最小化,但仍覆盖后续实现所需的导出 + refine + 监督?
3. proposal 是否需要声明 "默认行为不变,仅在显式开启 refine 时生效" 以避免潜在 breaking?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳): proposal 明确写出范围/非目标/成功标准

- 思路:
  - 在 `Why/What Changes/Impact` 里显式写明:
    - 连续表面目标(多视几何一致性,减少浮空点/碎裂/断层).
    - 非目标: 不引入薄片正则,不强行替换现有 gsplat 训练路径.
    - 默认行为不变,新增能力为可选 refine 后端.
- 优点:
  - 之后写 design/specs 时不容易跑偏.
  - 能减少“连续表面=薄片”的沟通成本.
- 代价:
  - proposal 文字会稍长一点,但仍控制在 1-2 页.

### 方案B(先能用,但风险高): proposal 只写一句话动机,细节放到 design

- 优点:
  - 写得快.
- 缺点:
  - 容易让后续 artifact 缺少明确 contract,导致 scope 漂移.

## 做出的决定

- [2026-02-28T11:12:31Z] 选择方案A. 原因: 这类训练方法的误解成本很高,proposal 需要先把边界和验收目标说清楚.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已写入 `openspec/changes/integrate-fastgs-continuous-surface/proposal.md`,并通过 `openspec status` 验证 `proposal` 完成,解锁 `design/specs`.

## 进展日志

- [2026-02-28T11:12:31Z] 开始撰写 proposal: 重点先把 "连续表面 != 薄片" 与 "可选 refine 后端,默认不改变现有行为" 写清楚.
- [2026-02-28T11:14:53Z] 已新增 `openspec/changes/integrate-fastgs-continuous-surface/proposal.md`.
- [2026-02-28T11:15:15Z] 已验证 `openspec status`: progress `1/4`,并解锁 `design/specs`.

---

# 任务计划: 编写 OpenSpec design + specs: integrate-fastgs-continuous-surface

## 目标

1. 完成 `openspec/changes/integrate-fastgs-continuous-surface/design.md`.
2. 按 proposal 的 capabilities,补齐 3 份 spec 文件:
   - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-dataset-export/spec.md`
   - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-refine/spec.md`
   - `openspec/changes/integrate-fastgs-continuous-surface/specs/continuous-surface-supervision/spec.md`
3. 通过 `openspec status` 验证 `design/specs` 完成,从而解锁 `tasks`.

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. “FastGS”在本项目里的落地形态:
   - 依赖外部 repo/二进制,还是把 FastGS 的关键策略(多视一致 densify/prune)内嵌进现有训练器?
2. dataset export 的最小可用规范是什么:
   - 哪些文件是 MUST(训练必需),哪些是 SHOULD(诊断/可复现)?
3. 连续表面监督的验收标准如何写成可测试的场景:
   - 例如深度/法线一致性指标,以及“浮空点减少”的可观测信号.

## 可选方案(至少两个方向)

### 方案A(最佳方案,更符合"改良胜过新增"): 内嵌 FastGS-style 策略到现有训练器

- 思路:
  - 不依赖外部 FastGS repo(避免不可控与维护成本).
  - 在 `gsplat` 训练循环中加入:
    - 多视一致的重要性评分(用于 densify/prune).
    - 以 depth/normal priors 为主的几何监督,推动连续表面.
- 优点:
  - 代码路径更统一,易于调试与回归.
  - 减少外部依赖,更可持续.
- 代价:
  - 需要我们在 design 中把关键算法与接口讲清楚.

### 方案B(先能用,但依赖多): 独立 refine runner + 外部工具链

- 思路:
  - 导出数据集后交给独立 runner(可能是外部 repo/脚本)跑 refine.
- 优点:
  - 与主 pipeline 解耦.
- 缺点:
  - 外部依赖容易漂移,复现与维护成本更高.

## 做出的决定

- [2026-02-28T11:18:49Z] 默认选择方案A(内嵌 FastGS-style). 原因: 当前官方 FastGS repo 未开源完整代码,且项目更需要稳定可维护的内嵌能力.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已完成 `design/specs/tasks` 三个 artifacts,并通过 `openspec status` 验证 progress `4/4`.

## 进展日志

- [2026-02-28T11:18:49Z] 已获取 `design/specs` 的 openspec instructions. 下一步开始落盘 design.md 与 specs/*.md.
- [2026-02-28T11:25:05Z] 已新增 `openspec/changes/integrate-fastgs-continuous-surface/design.md`.
- [2026-02-28T11:25:05Z] 已新增三份 spec:
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-dataset-export/spec.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/fastgs-refine/spec.md`
  - `openspec/changes/integrate-fastgs-continuous-surface/specs/continuous-surface-supervision/spec.md`
- [2026-02-28T11:25:05Z] `openspec status` 验证 progress `3/4`,并解锁 `tasks`.
- [2026-02-28T11:25:05Z] 已新增 `openspec/changes/integrate-fastgs-continuous-surface/tasks.md`,并通过 `openspec status` 验证 progress `4/4`.

---

# 任务计划: 实现 fastgs-dataset-export(导出 refine 数据集)

## 目标

在不改变默认行为的前提下:
1. 为 single-image 与 multi-image pipeline 增加可选的数据集导出能力(opt-in).
2. 导出的目录结构满足 OpenSpec 的 `fastgs-dataset-export` 规格:
   - `images/`
   - `sparse/0/cameras.txt` + `sparse/0/images.txt`
   - `priors/depth/*.npy`
   - `priors/normal/*.npy`
   - `masks/*.png`
   - `meta.json`
3. 增加严格校验函数,缺文件时 fail-fast 并给出清晰路径提示.
4. 增加 pytest 单测,覆盖:
   - 新导出目录结构完整性
   - 默认不覆盖非空目录
   - COLMAP 文件的数量/命名一致性

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. exporter 的输入边界如何统一(单图有 `Frame`,多图有 `MultiviewPred`)?
2. depth/normal priors 的来源与坐标系如何记录到 `meta.json`,避免后续 refine 误用?
3. mask 的语义如何定义才能稳定(避免把边界噪声/无效深度带入监督)?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳): 做一个统一 exporter + 两个 adapter

- 思路:
  - exporter 核心只吃统一的 view 列表(含 rgb/K/world_T_cam/depth/normal/mask).
  - single-image: 从 `Gaussian_Scene.frames` 转换成 views.
  - multi-image: 从 `mv_pred_list` + depth_conf/edges 构造 views.
- 优点:
  - 导出结构与校验逻辑只有一份,易回归.
  - 后续 refine runner 可以直接复用校验函数.
- 代价:
  - 需要新增一个模块文件,但这是“必要抽象”,不会造成屎山式堆叠.

### 方案B(先能用,但更乱): 两条 pipeline 各写一份导出逻辑

- 优点:
  - 写得快.
- 缺点:
  - 两套目录结构/命名/校验很容易分叉,后续维护成本高.

## 做出的决定

- [2026-02-28T12:15:17Z] 选择方案A. 原因: exporter 是后续 refine 的接口契约,必须统一与可复现.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已实现统一 exporter 与 pipeline adapter,并通过 pytest/ruff 验证通过.

## 进展日志

- [2026-02-28T12:15:17Z] 用户确认实现顺序: 先做 `fastgs-dataset-export`,再进入 refine runner.

## 2026-02-28T12:39:33Z

- 已完成实现与验证 `fastgs-dataset-export`:
  - 新增统一 exporter: `src/vistadream/ops/gs/fastgs_dataset.py`.
  - single-image pipeline opt-in 导出: `src/vistadream/api/single_img_pipeline.py`.
  - multi-image pipeline opt-in 导出: `src/vistadream/api/multi_image_pipeline.py`.
  - 新增单测: `tests/test_fastgs_dataset_export.py`.
  - 已在 pixi dev 环境跑通 `pytest -q`,并对改动文件执行 ruff 检查.

- 状态更新:
  - 将 `fastgs-dataset-export` 视为已完成,下一步进入 refine runner + 连续表面监督.

---

# 任务计划: 实现 fastgs-refine + continuous-surface-supervision(连续表面监督)

## 目标

在不引入薄片(thinness)/厚度(thickness)正则的前提下:

1. 提供一个显式 refine 入口(API/CLI),输入 `dataset_dir`,`init_gaussians(.ply)`,`result_dir`.
2. refine 运行前严格校验输入,缺关键文件 fail-fast.
3. refine 过程中引入连续表面几何监督:
   - per-view depth scale+shift 对齐.
   - mask-aware depth/normal 损失(鲁棒,NaN/Inf 安全).
4. refine 完成后写出:
   - `gaussians_refined.ply`
   - `refine_meta.json`(provenance + 对齐参数 + 几何指标)
5. 为关键数学组件补齐单测,确保可回归.

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. dataset 的相机外参约定是 world_T_cam 还是 cam_T_world? refine 渲染需要哪一种?
2. 深度对齐(scale+shift)如何做成稳定的 mask-aware 拟合,并避免梯度穿过对齐参数导致退化?
3. 渲染法线如何生成(由渲染深度差分),以及如何保证符号不敏感 normal loss?
4. 如何在不跑 GPU 重训练的前提下,用单测覆盖核心数学逻辑与输入校验?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更稳): 先实现 supervision 数学组件,再封装 refine runner

- 思路:
  - 把 depth 对齐、depth loss、normal from depth、normal loss 独立成可单测的函数.
  - refine runner 只负责: 读数据集/渲染/调用 loss/写 meta.
- 优点:
  - 数学逻辑可单测,不依赖 GPU.
  - runner 更薄,未来可替换渲染后端或加 densify/prune.

### 方案B(先能用,但更难测): 直接在 refine runner 里内联所有逻辑

- 优点:
  - 写得快.
- 缺点:
  - 难以为核心公式写单测,容易引入隐性 bug.

## 做出的决定

- [2026-02-28T12:39:33Z] 选择方案A. 原因: 连续表面监督的正确性依赖数学细节,必须可单测与可回归.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已实现 refine runner + 连续表面监督(深度/法线)并通过 pytest/ruff 验证.

## 进展日志

- [2026-02-28T12:59:06Z] 已实现 continuous-surface-supervision(可单测):
  - `src/vistadream/ops/gs/continuous_surface_supervision.py`:
    - per-view depth scale+shift 对齐.
    - mask-aware depth SmoothL1/Huber 损失.
    - 由渲染深度生成 normal map.
    - 符号不敏感法线损失(1-abs(dot)).

- [2026-02-28T12:59:06Z] 已实现 fastgs-refine runner + CLI:
  - `src/vistadream/ops/gs/refine.py`: 输入校验,加载 dataset+PLY,训练,写出 `gaussians_refined.ply` + `refine_meta.json`.
  - `tools/run_fastgs_refine.py`: 独立 CLI 入口.
  - `src/vistadream/ops/gs/basic.py`: 新增 `load_ply_as_gaussian_scene` 用于从 PLY 加载高斯.

- [2026-02-28T12:59:06Z] 已接入 pipeline(默认关闭,opt-in):
  - `src/vistadream/api/single_img_pipeline.py`: 增加 dataset export + refine 开关与输出目录.
  - `src/vistadream/api/multi_image_pipeline.py`: 增加可选 refine 触发(需要用户提供 init gaussians PLY).

- [2026-02-28T12:59:06Z] 已补齐测试与文档:
  - 新增 tests: `tests/test_continuous_surface_supervision.py`,`tests/test_fastgs_refine_validation.py`.
  - 更新: `README.md`,`docs/single_img_pipeline.md`.

- [2026-02-28T12:59:06Z] 验证通过:
  - `pixi run -e dev pytest -q` -> 9 passed.
  - `pixi run -e dev ruff check <改动文件>` -> All checks passed.
  - `openspec instructions apply --change integrate-fastgs-continuous-surface --json` -> 30/30 tasks complete.

## 2026-02-28T13:58:50Z

- 补充端到端测试覆盖 refine runner:
  - 新增 GPU smoke test: `tests/test_fastgs_refine_smoke.py`.
  - 该测试会在 CUDA 可用时实际跑一次最小 refine(2 iters),验证产物与 metrics 写出.

- 再次验证:
  - `pixi run -e dev pytest -q` -> 10 passed.

---

# 任务计划: coarse vs fine 的 PLY 差异可观测性 + coarse 更激进

## 目标

让单图流程在 `--stage coarse` 场景下:

1. 运行结束时能明确回答: "coarse 是否真的选到了新视角帧? 一共选了几帧? 每帧洞(inpaint)比例是多少? 新增了多少高斯基元(splats)?"
2. 用户可以通过 CLI 参数把 coarse 调得更激进,从而更容易补到新帧,并在 PLY 上看到更明显的几何差异(而不是肉眼看不出区别).

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建
- [x] 阶段4: 审查和交付

## 关键问题

1. `--stage coarse` 运行时,是否真的挑选并加入了新的 inpaint 帧? 目前缺少可验证的结构化摘要.
2. coarse 选帧逻辑的阈值(例如最大洞比例)是否过保守,导致经常选不到新帧,最终 PLY 与 `fine` 差异很小?
3. 哪些参数最影响 "能否选到新帧" 与 "差异是否肉眼可见": 轨迹幅度,margin,洞比例阈值,相邻帧排除窗口,采样密度等.

## 可选方案(至少两个方向)

### 方案A(最佳方案,更可控): coarse 结构化摘要 + CLI 参数化选帧/轨迹,并补齐单测

- 增加 coarse 运行摘要(打印+可选写 JSON): 选中帧索引,每帧 inpaint 比例,新增 splats 数量,最终总 splats 数.
- 把 coarse 选帧策略参数化(保持默认值不变):
  - `coarse_max_inpaint_ratio`(默认 0.25),`coarse_min_inpaint_ratio`(默认 0.05)
  - `coarse_dense_multiplier`(默认 10),`coarse_margin`(默认 32)
  - `coarse_adjacent_exclusion`(默认 1,表示剔除 ±1 帧)
- (可选但推荐) 把相机轨迹关键参数暴露为 CLI,并保证所有 traj 实现返回一致的 `cam_T_world`,避免用户调 traj_type 时踩坑.
- 增加单测,确保:
  - 阈值变化会影响选帧结果.
  - coarse 摘要统计字段稳定存在.

### 方案B(先能用,后面再优雅): 只加 summary print + 一个关键阈值开关

- 只加 coarse 结束时的 summary print.
- 只暴露 `coarse_max_inpaint_ratio` 一个参数,先让用户能把 coarse 调得更激进,其余保持写死.
- 不处理 traj 实现不一致问题.

## 做出的决定

- [2026-03-01T06:14:26Z] 选择方案A. 原因: 你希望同时 "确认是否选到新帧" 与 "让 coarse 更激进",需要可观测性 + 可调参数这两件事一起落地,否则很难稳定复现和定位.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已为 `--stage coarse` 增加结构化摘要(选帧索引/inpaint 比例/新增 splats),并把 coarse 选帧与轨迹关键参数暴露为 CLI,同时补齐单测与 ruff/pytest 验证.

## 进展日志

- [2026-03-01T06:25:36Z] 增加 coarse 选帧摘要:
  - `src/vistadream/api/single_img_pipeline.py`:
    - coarse 结束后输出 Summary,明确 `selected_extra_frames`/每帧 `inpaint_ratio`/`added_splats`/`total_splats`.
    - 将选帧逻辑抽为纯函数 `_select_best_pose_index`,便于单测与调参.

- [2026-03-01T06:25:36Z] 暴露 coarse 可调参数(保持默认值不变):
  - `coarse_dense_multiplier`,`coarse_margin`
  - `coarse_max_inpaint_ratio`,`coarse_min_inpaint_ratio`
  - `coarse_adjacent_exclusion`,`coarse_print_summary`

- [2026-03-01T06:25:36Z] 暴露轨迹幅度参数(写回 `Gaussian_Scene`):
  - `traj_forward_ratio`,`traj_backward_ratio`
  - `traj_min_percentage`,`traj_max_percentage`

- [2026-03-01T06:25:36Z] 单测与验证:
  - 新增 `tests/test_coarse_frame_selection.py` 覆盖 `_select_best_pose_index` 的阈值与相邻剔除行为.
  - `pixi run -e dev pytest -q` 通过.
  - `pixi run -e dev ruff check <改动文件>` 通过.

---

# 任务计划: 评估 FreeTimeGsVanilla 的 "COLMAP + RoMa(romatch) 密集匹配/三角化" 对 Vistadream 的借鉴价值

## 目标

把问题说清楚,避免概念混淆:

1. FreeTimeGsVanilla 里 "COLMAP + RoMa" 各自解决的是什么问题?
2. Vistadream 当前是否存在同类瓶颈,值得引入 RoMa/学习式匹配?
3. 如果要借鉴,最小可落地的路线是什么,代价在哪里?

## 阶段

- [x] 阶段1: 计划和设置
- [x] 阶段2: 研究/收集信息
- [x] 阶段3: 执行/构建(本任务是技术评估,不做功能实现)
- [x] 阶段4: 审查和交付

## 关键问题

1. FreeTimeGsVanilla 的 RoMa 是 "喂给 COLMAP 做 SfM" 还是 "在已知相机位姿下做逐帧三角化"?
2. Vistadream 是否真的有 "跑 COLMAP" 的环节? 还是只是导出 COLMAP 格式用于互操作?
3. RoMa 的优势(密集匹配)是否与 Vistadream 当前的深度/位姿来源(learned)互补,还是重复建设?

## 可选方案(至少两个方向)

### 方案A(最佳方案,更通用但代价高): 需要几何 SfM 时,引入 "学习式匹配 -> COLMAP/pycolmap" 的可选管线

- 目标: 当用户给的是多视图照片/视频抽帧,且希望得到传统 SfM 一致的相机/点云时,提供一条可复现的几何管线.
- 做法(高层):
  - 用学习式匹配器(例如 RoMa/LoFTR 等)生成 matches.
  - 导入到 COLMAP/pycolmap,跑 mapper/BA 得到相机位姿与稀疏点云.
  - 将该结果作为 3DGS 初始化/监督输入.
- 代价: 引入 COLMAP/pycolmap/匹配器依赖,以及 pair 生成与缓存策略,工程面不小.

### 方案B(先能用,更轻量): 仅借鉴 FreeTime 的 "RoMa + RANSAC + 三角化 + voxel 去重" 作为可选几何 sanity check

- 目标: 不把 Vistadream 变成 SfM 工具链,但在 multi-image 场景下,可以用几何三角化点云做:
  - 位姿质量自检(匹配 inlier 比例,三角化有效点比例).
  - 和 learned depth 点云做对照(发现明显漂移/尺度问题).
- 代价: 仍需要新增 `romatch` 依赖,且三角化的效果高度依赖输入位姿质量.

## 做出的决定

- [2026-03-01T06:16:55Z] 结论: "借鉴价值存在,但对 Vistadream 当前主流程不是刚需". 原因:
  - FreeTimeGsVanilla 的 RoMa 主要服务于 "多相机静态 rig + 动态序列" 的逐帧点云,这类输入形态与 Vistadream 的单图/少图 learned 深度路线不同.
  - Vistadream 的 `colmap` 相关代码目前是导出互操作格式,并没有依赖 COLMAP 做位姿求解.

## 遇到错误

- (暂无)

## 状态

**已完成**: 已澄清 FreeTimeGsVanilla 的 RoMa 用途与 Vistadream 的对应关系,并给出两条后续可落地路线(A/B)与取舍.

## 进展日志

- [2026-03-01T06:16:55Z] 调研 FreeTimeGsVanilla:
  - `src/preprocess_mp4_freetimegs.py` 明确是 "参考帧跑一次 COLMAP + RoMa 逐帧三角化".
  - 实现策略: anchor camera 与其它相机做 RoMa 密集匹配,用 F 矩阵 RANSAC(USAC_MAGSAC)过滤外点,已知位姿下三角化,最后 voxel 去重控制规模.
- [2026-03-01T06:16:55Z] 调研 Vistadream:
  - `src/vistadream/api/multi_image_pipeline.py` 的 `write_colmap_*.txt` 仅用于导出 COLMAP txt 兼容格式,位姿/深度来自 learned multiview 模型(VGGT)与 MoGe.

---

# 任务计划: coarse 选帧失败的原因诊断 + 可选更激进选帧

## 目标

在 `--stage coarse` 出现 "No more suitable frames found for inpainting" 时:

1. 不用猜. 直接输出 inpaint_ratio 的分布与被过滤原因(太小/太大/相邻剔除).
2. 用户可通过一个显式开关让 coarse 更激进,即使不满足阈值也能选到新帧(用于确认流程与制造更明显几何差异).

## 阶段

- [ ] 阶段1: 计划和设置
- [ ] 阶段2: 研究/收集信息
- [ ] 阶段3: 执行/构建
- [ ] 阶段4: 审查和交付

## 关键问题

1. 你这次 `selected_extra_frames=0` 的根因是哪一种?
   - A. 所有候选洞都 < `coarse_min_inpaint_ratio`(洞太小,需要更大 motion/margin 或降低 min).
   - B. 所有候选洞都 > `coarse_max_inpaint_ratio`(洞太大,需要放宽 max 或减小 motion).
2. 如果根因是 B(洞太大),最合理的 "更激进" 方式是什么?
   - 先选 "最接近阈值的帧"(最小的洞)继续推进,而不是直接选洞最大的帧.

## 做出的决定

- [2026-03-01T07:21:34Z] 增加 coarse 选帧失败诊断日志,并提供 `coarse_fallback_mode`(默认关闭) 作为显式兜底.
  - 原因: 你的目标不仅是 "更激进",更关键是 "知道为什么没选到".

## 状态

**目前在阶段1**: 追加计划,准备实现诊断与 fallback.

## 进展日志

- [2026-03-01T07:28:24Z] 已完成 coarse 选帧失败诊断 + fallback:
  - 选不到帧时,会打印 `[COARSE][DIAG]` 的 ratio 分布(min/mean/max)、过滤计数(below_min/in_range/above_max)、以及 top-k 候选(idx:ratio).
  - 新增 `coarse_fallback_mode={none,closest}`(默认 none). 开启后即使不满足阈值也会选“最接近阈值区间”的帧继续推进.
  - 新增单测覆盖 fallback 行为,并通过 `pytest/ruff` 验证.

## 状态

**已完成**: coarse 现在能解释“为什么没选到帧”,并支持显式更激进的兜底选帧.

---

# 任务计划: 将 coarse 诊断与调参指南写入 docs

## 目标

把我们刚刚讨论的这些“可操作的经验”沉淀到项目文档里,让下次遇到 `selected_extra_frames=0` 时不需要翻聊天记录:

- `--stage coarse` 没选到新帧时,如何用日志判断根因(洞太小/洞太大/相邻剔除).
- 如何把 coarse 调得更激进,确保真的补到新帧并带来更明显几何差异(包括 `--coarse-fallback-mode closest`).
- 澄清 `--stage fine/outpaint/coarse/no-outpaint` 的语义与默认值.

## 阶段

- [ ] 阶段1: 计划和设置
- [ ] 阶段2: 收集现有 docs 结构
- [ ] 阶段3: 修改 docs 并补充示例
- [ ] 阶段4: 审查和交付

## 做出的决定

- [2026-03-01T07:42:45Z] 优先更新 `docs/single_img_pipeline.md`,并在必要时对 `docs/spiral_trajectory_explained.md` 做最小同步.
  - 原因: 这些指导意见与单图 pipeline 的 stage/coarse 选帧逻辑强相关,放在 single_img_pipeline 文档里最容易被找到.

## 状态

**目前在阶段1**: 准备更新 docs.
